#!/bin/bash

# Dev TODOs:
# 0) Upload to bajuwa github repo
# 1) Upgrade the 'whitespace splitting' logic to handle mid-panel splits
# 2) Alter option from 'min images per page' to 'minimum height of page'

# Requirements: ImageMagick (needs to be on PATH)

MIN_IMAGES_PER_PAGE=5
INPUT_IMAGE_NAME_PREFIX="image"
IMAGE_FILE_EXTENSION="jpg"
OUTPUT_PAGE_NAME_PREFIX="page"
INPUT_DIRECTORY="./"
OUTPUT_DIRECTORY="./"
SPLIT_ON_COLOUR=65535 # Decimal colour value (65535 = white)
COLOUR_ERROR_TOLERANCE=0 # Just in case your 'whites' aren't perfectly white

# Parse for optional arguments
for i in "$@"
do
case $1 in
    -p|--images-per-page)
    MIN_IMAGES_PER_PAGE=$2
    shift # past argument=value
    ;;
    -i|--input-file-prefix)
    INPUT_IMAGE_NAME_PREFIX=$2
    shift # past argument=value
    ;;
    -c|--split-on-colour|--split-on-color)
    SPLIT_ON_COLOUR=$2
    shift # past argument=value
    ;;
    -cE|--colour-error-tolerance|--color-error-tolerance)
    COLOUR_ERROR_TOLERANCE=$2
    shift # past argument=value
    ;;
    -e|--extension)
    IMAGE_FILE_EXTENSION=$2
    shift # past argument=value
    ;;
    -o|--output-file-prefix)
    OUTPUT_PAGE_NAME_PREFIX=$2
    shift # past argument=value
    ;;
    -id|--input-directory)
    INPUT_DIRECTORY=$2
    shift # past argument=value
    ;;
    -od|--output-directory)
    OUTPUT_DIRECTORY=$2
    shift # past argument=value
    ;;
esac
shift
done

echo "Running ComCom with options: "
echo "MIN_IMAGES_PER_PAGE=$MIN_IMAGES_PER_PAGE"
echo "INPUT_IMAGE_NAME_PREFIX=$INPUT_IMAGE_NAME_PREFIX"
echo "OUTPUT_PAGE_NAME_PREFIX=$OUTPUT_PAGE_NAME_PREFIX"
echo "INPUT_DIRECTORY=$INPUT_DIRECTORY"
echo "OUTPUT_DIRECTORY=$OUTPUT_DIRECTORY"
echo "IMAGE_FILE_EXTENSION=$IMAGE_FILE_EXTENSION"
echo "SPLIT_ON_COLOUR=$SPLIT_ON_COLOUR"
echo "COLOUR_ERROR_TOLERANCE=$COLOUR_ERROR_TOLERANCE"
echo ""

function fileEndsInWhitespace {
  # $1 should be the file name
  width=$(identify -format "%w" $1)
  height=$(identify -format "%h" $1)
  height=$((height-1))
  fileSampling="$1["$width"x1+0+$height]"
  grayMeanValue=$(identify -format %[mean] $fileSampling)
  standardDeviation=$(identify -format %[standard-deviation] $fileSampling)
  colourDifference=$((${grayMeanValue%.*} - $SPLIT_ON_COLOUR))
  if [ $colourDifference -le $COLOUR_ERROR_TOLERANCE ] && [ ${standardDeviation%.*} -lt 1 ]
	then 
		#echo "This image ends in whitespace: " $1;
		true
	else 
		#echo "This image does not end in whitespace: " $1;
		false
  fi
};

function combineImages {
	pageIndex=0;
	imageIndex=0;
	totalImageCount=${#imageFileNames[@]};

	while [ $imageIndex -lt $totalImageCount ]
	do
		imageBatchSize=$MIN_IMAGES_PER_PAGE
		# find the next page separation spot (test for line of whitespace)
		# MVP : just test for images that end with one complete line of all whitespace
		# Upgrade : test for whitespace in middle of file (if has whitespace, then append and crop both pages)
		while [ $imageBatchSize -lt $((totalImageCount-imageIndex)) ]
		do
			imageIndexToTest=$((imageIndex+imageBatchSize))
			# If the image we're on ends in clean whitespace, break loop to end using that file
			if fileEndsInWhitespace ${imageFileNames[$imageIndexToTest]}
				then break
				else imageBatchSize=$((imageBatchSize+1))
			fi
		done
		
		# Now that we've picked out our image range, combine them to a single file
		pageFileName=$(printf "$OUTPUT_PAGE_NAME_PREFIX%03d.$IMAGE_FILE_EXTENSION" $pageIndex)
		echo "Combining into '$pageFileName': $imageIndex - $((imageIndex+imageBatchSize))"
		convert -append ${imageFileNames[@]:$imageIndex:$imageBatchSize+1} -colorspace sRGB $OUTPUT_DIRECTORY$pageFileName;
		
		# Increment our index for the next round
		pageIndex=$((pageIndex+1));
		imageIndex=$((imageIndex+imageBatchSize+1));
	done
};

# find all files to be combined
# allow using null-char for file name split (better array parsing) via: -print0 
imageFileNames=()
while IFS=  read -r -d $'\0'; do
    imageFileNames+=("$REPLY")
done < <(find $INPUT_DIRECTORY -type f -iname "$INPUT_IMAGE_NAME_PREFIX*.$IMAGE_FILE_EXTENSION" -printf "%f\0")
# echo ${imageFileNames[*]};

if [ ${#imageFileNames[@]} -eq 0 ]; 
then
    echo "Couldn't find any images to combine";
else
	mkdir -p $OUTPUT_DIRECTORY;
    combineImages;
	echo ""
	echo "Comic Compilation - Complete!"
fi